grid = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]
k = 4
#grid = [[0,0],[1,0],[1,0],[1,0],[1,0],[1,0],[0,0],[0,1],[0,1],[0,1],[0,0],[1,0],[1,0],[0,0]]
def isValidIndex(i, j, m, n):
    if(i<0 or i>=m):
        return False
    if(j<0 or j>=n):
        return False
    return True

'''
def shortestPathInMatrixWithObstacles(matrix, visited, numBreaksLeft, i, j, m, n, length, minLength, dp):

    if(dp[i][j][numBreaksLeft]==-1):
        return -1
    if(i==m-1 and j==n-1):
        if (matrix[i][j]==1 and numBreaksLeft>=1) or matrix[i][j]==0:
            if(length<minLength[0]):
                minLength[0] = length
                
    
    #DLRU
    dX = [1, 0, 0, -1]
    dY = [0, -1, 1, 0]
    retVal = -4
    for (dx, dy) in zip(dX, dY):
        if isValidIndex(i+dx, j+dy, m, n) and visited[i+dx][j+dy]==0:
            if matrix[i+dx][j+dy] == 0:
                visited[i+dx][j+dy] = 1
                retVal += shortestPathInMatrixWithObstacles(matrix, visited, numBreaksLeft, i+dx, j+dy, m, n, length+1, minLength, dp)
                visited[i+dx][j+dy] = 0
            elif numBreaksLeft>0:
                visited[i+dx][j+dy] = 1
                retVal += shortestPathInMatrixWithObstacles(matrix, visited, numBreaksLeft - 1, i+dx, j+dy, m, n, length+1, minLength, dp)
                visited[i+dx][j+dy] = 0
    dp[i][j][numBreaksLeft] = -1 if retVal==0 else 0
        
    return -1

m = len(grid)
n = len(grid[0])
visited = [[0 for y in range(0, n)] for x in range(0,m)]
dp = [[[0 for z in range(0,k+1)] for y in range(0, n)] for x in range(0,m)]

if(grid[0][0]==1):
    k = k-1
minLength = [1e9]

(shortestPathInMatrixWithObstacles(grid, visited, k, 0, 0, m, n, 0, minLength, dp))
print(minLength[0] if minLength[0]<1e9 else -1)

'''


from collections import deque 



def shortestPath(grid, k):
    m, n = len(grid), len(grid[0])
    Q, v = deque([(0, 0, 0, k)]), set()
  
    if k >= m + n - 2: 
        return m + n - 2
  
    while Q:
        steps, x, y, k = Q.popleft()
        if (x, y) == (n-1, m-1): return steps
      
        for dx, dy in (x, y-1), (x, y+1), (x-1, y), (x+1, y):
            if 0 <= dx < n and 0 <= dy < m and k - grid[dy][dx] >= 0:
                new = (dx, dy, k - grid[dy][dx])
                if new not in v:
                    v.add(new)
                    Q.append((steps + 1,) + new)
      
    return -1
     
print(shortestPath(grid,k))

def shortestPathInMatrixWithObstaclesWIthBFS(grid, k):
    m = len(grid)
    n = len(grid[0])
    visited = set()
    queue = deque()
    queue.append([0,0,k,0])
    
    while(len(queue)>0):
        
        elem = queue.popleft()
        i = elem[0]
        j = elem[1]
        remK = elem[2]
        steps = elem[3]
        if(i==m-1 and j==n-1):
            return steps

        for (dx,dy) in [(1,0),(0,-1),(0,1),(-1,0)]:
                if(isValidIndex(i+dx, j+dy, m, n)):
                    if(grid[i+dx][j+dy]==1 and remK>0 and (i+dx, j+dy, remK-1) not in visited):
                        queue.append([i+dx, j+dy, remK-1, steps+1])  
                        visited.add((i+dx, j+dy, remK-1))

                    elif(grid[i+dx][j+dy]==0  and (i+dx, j+dy, remK) not in visited):
                        queue.append([i+dx, j+dy, remK, steps+1])
                        visited.add((i+dx, j+dy, remK))

    return -1
     
print(shortestPathInMatrixWithObstaclesWIthBFS(grid,k))
